{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/app/api/api.ts"],"sourcesContent":["import axios from 'axios';\n\nexport const api = axios.create({\n  baseURL: 'https://notehub-api.goit.study',\n  withCredentials: true,\n});\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,MAAM,wJAAK,CAAC,MAAM,CAAC;IAC9B,SAAS;IACT,iBAAiB;AACnB"}},
    {"offset": {"line": 30, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/lib/api/serverApi.ts"],"sourcesContent":["import type { Note } from \"@/types/note\";\nimport type { User } from \"@/types/user\";\nimport type { Session } from \"@/types/session\";\nimport { cookies } from \"next/headers\";\nimport { api } from \"@/app/api/api\";\nimport type { AxiosResponse } from \"axios\";\n\nexport const fetchNotes = async (params?: {\n  search?: string;\n  page?: number;\n  perPage?: number;\n  tag?: string;\n}): Promise<Note[]> => {\n  const cookieStore = cookies();\n  const accessToken = cookieStore.get('accessToken')?.value;\n  const refreshToken = cookieStore.get('refreshToken')?.value;\n\n  // Build Cookie header manually\n  const cookieHeader = [\n    accessToken && `accessToken=${accessToken}`,\n    refreshToken && `refreshToken=${refreshToken}`,\n  ]\n    .filter(Boolean)\n    .join('; ');\n\n  const { data } = await api.get<Note[]>(\"/notes\", {\n    params,\n    headers: { Cookie: cookieHeader },\n  });\n\n  return data;\n};\n\nexport const fetchNoteById = async (id: string): Promise<Note> => {\n  const cookieStore = cookies();\n  const accessToken = cookieStore.get('accessToken')?.value;\n  const refreshToken = cookieStore.get('refreshToken')?.value;\n\n  // Build Cookie header manually\n  const cookieHeader = [\n    accessToken && `accessToken=${accessToken}`,\n    refreshToken && `refreshToken=${refreshToken}`,\n  ]\n    .filter(Boolean)\n    .join('; ');\n\n  const { data } = await api.get<Note>(`/notes/${id}`, {\n    headers: { Cookie: cookieHeader },\n  });\n\n  return data;\n};\n\nexport const getMe = async (): Promise<User> => {\n  try {\n    const cookieStore = cookies();\n    const accessToken = cookieStore.get('accessToken')?.value;\n    const refreshToken = cookieStore.get('refreshToken')?.value;\n\n    // Build Cookie header manually\n    const cookieHeader = [\n      accessToken && `accessToken=${accessToken}`,\n      refreshToken && `refreshToken=${refreshToken}`,\n    ]\n      .filter(Boolean)\n      .join('; ');\n\n    if (!cookieHeader) {\n      throw new Error('No authentication tokens found');\n    }\n\n    const { data } = await api.get<User>(\"/users/me\", {\n      headers: { Cookie: cookieHeader },\n    });\n\n    return data;\n  } catch (error) {\n    console.error('getMe error:', error);\n    throw error;\n  }\n};\n\nexport const checkSession = async (): Promise<AxiosResponse<Session> | null> => {\n  try {\n    const cookieStore = cookies();\n    const accessToken = cookieStore.get('accessToken')?.value;\n    const refreshToken = cookieStore.get('refreshToken')?.value;\n\n    // Build Cookie header manually\n    const cookieHeader = [\n      accessToken && `accessToken=${accessToken}`,\n      refreshToken && `refreshToken=${refreshToken}`,\n    ]\n      .filter(Boolean)\n      .join('; ');\n\n    const response = await api.get<Session>(\"/auth/session\", {\n      headers: {\n        Cookie: cookieHeader,\n      },\n    });\n\n    return response;\n  } catch {\n    return null;\n  }\n};"],"names":[],"mappings":";;;;;;;;;;AAGA;AAAA;AACA;;;AAGO,MAAM,aAAa,OAAO;IAM/B,MAAM,cAAc,IAAA,sLAAO;IAC3B,MAAM,cAAc,YAAY,GAAG,CAAC,gBAAgB;IACpD,MAAM,eAAe,YAAY,GAAG,CAAC,iBAAiB;IAEtD,+BAA+B;IAC/B,MAAM,eAAe;QACnB,eAAe,CAAC,YAAY,EAAE,aAAa;QAC3C,gBAAgB,CAAC,aAAa,EAAE,cAAc;KAC/C,CACE,MAAM,CAAC,SACP,IAAI,CAAC;IAER,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,gIAAG,CAAC,GAAG,CAAS,UAAU;QAC/C;QACA,SAAS;YAAE,QAAQ;QAAa;IAClC;IAEA,OAAO;AACT;AAEO,MAAM,gBAAgB,OAAO;IAClC,MAAM,cAAc,IAAA,sLAAO;IAC3B,MAAM,cAAc,YAAY,GAAG,CAAC,gBAAgB;IACpD,MAAM,eAAe,YAAY,GAAG,CAAC,iBAAiB;IAEtD,+BAA+B;IAC/B,MAAM,eAAe;QACnB,eAAe,CAAC,YAAY,EAAE,aAAa;QAC3C,gBAAgB,CAAC,aAAa,EAAE,cAAc;KAC/C,CACE,MAAM,CAAC,SACP,IAAI,CAAC;IAER,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,gIAAG,CAAC,GAAG,CAAO,CAAC,OAAO,EAAE,IAAI,EAAE;QACnD,SAAS;YAAE,QAAQ;QAAa;IAClC;IAEA,OAAO;AACT;AAEO,MAAM,QAAQ;IACnB,IAAI;QACF,MAAM,cAAc,IAAA,sLAAO;QAC3B,MAAM,cAAc,YAAY,GAAG,CAAC,gBAAgB;QACpD,MAAM,eAAe,YAAY,GAAG,CAAC,iBAAiB;QAEtD,+BAA+B;QAC/B,MAAM,eAAe;YACnB,eAAe,CAAC,YAAY,EAAE,aAAa;YAC3C,gBAAgB,CAAC,aAAa,EAAE,cAAc;SAC/C,CACE,MAAM,CAAC,SACP,IAAI,CAAC;QAER,IAAI,CAAC,cAAc;YACjB,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,gIAAG,CAAC,GAAG,CAAO,aAAa;YAChD,SAAS;gBAAE,QAAQ;YAAa;QAClC;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gBAAgB;QAC9B,MAAM;IACR;AACF;AAEO,MAAM,eAAe;IAC1B,IAAI;QACF,MAAM,cAAc,IAAA,sLAAO;QAC3B,MAAM,cAAc,YAAY,GAAG,CAAC,gBAAgB;QACpD,MAAM,eAAe,YAAY,GAAG,CAAC,iBAAiB;QAEtD,+BAA+B;QAC/B,MAAM,eAAe;YACnB,eAAe,CAAC,YAAY,EAAE,aAAa;YAC3C,gBAAgB,CAAC,aAAa,EAAE,cAAc;SAC/C,CACE,MAAM,CAAC,SACP,IAAI,CAAC;QAER,MAAM,WAAW,MAAM,gIAAG,CAAC,GAAG,CAAU,iBAAiB;YACvD,SAAS;gBACP,QAAQ;YACV;QACF;QAEA,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF"}},
    {"offset": {"line": 126, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport type { NextRequest } from \"next/server\";\nimport { checkSession } from \"./lib/api/serverApi\";\n\nconst PUBLIC_PATHS = [\"/sign-in\", \"/sign-up\"];\nconst PRIVATE_PATHS = [\"/profile\", \"/notes\"];\n\nexport async function middleware(req: NextRequest) {\n  const accessToken = req.cookies.get(\"accessToken\")?.value;\n  const refreshToken = req.cookies.get(\"refreshToken\")?.value;\n  const url = req.nextUrl.clone();\n\n  const isPublic = PUBLIC_PATHS.some((path) => url.pathname.startsWith(path));\n  const isPrivate = PRIVATE_PATHS.some((path) => url.pathname.startsWith(path));\n\n  if (!accessToken && refreshToken) {\n    const sessionResponse = await checkSession();\n\nif (!sessionResponse) {\n  url.pathname = \"/sign-in\";\n  return NextResponse.redirect(url);\n}\n\nconst session = sessionResponse.data;\n\n    const response = NextResponse.next();\n\n    response.cookies.set(\"accessToken\", session.accessToken, {\n      httpOnly: true,\n      path: \"/\",\n    });\n    if (session.refreshToken) {\n      response.cookies.set(\"refreshToken\", session.refreshToken, {\n        httpOnly: true,\n        path: \"/\",\n      });\n    }\n\n    return response;\n  }\n\n  if (!accessToken && isPrivate) {\n    url.pathname = \"/sign-in\";\n    return NextResponse.redirect(url);\n  }\n\n  if (accessToken && isPublic) {\n    url.pathname = \"/\";\n    return NextResponse.redirect(url);\n  }\n\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: [\"/profile/:path*\", \"/notes/:path*\", \"/sign-in\", \"/sign-up\"],\n};\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAEA;;;AAEA,MAAM,eAAe;IAAC;IAAY;CAAW;AAC7C,MAAM,gBAAgB;IAAC;IAAY;CAAS;AAErC,eAAe,WAAW,GAAgB;IAC/C,MAAM,cAAc,IAAI,OAAO,CAAC,GAAG,CAAC,gBAAgB;IACpD,MAAM,eAAe,IAAI,OAAO,CAAC,GAAG,CAAC,iBAAiB;IACtD,MAAM,MAAM,IAAI,OAAO,CAAC,KAAK;IAE7B,MAAM,WAAW,aAAa,IAAI,CAAC,CAAC,OAAS,IAAI,QAAQ,CAAC,UAAU,CAAC;IACrE,MAAM,YAAY,cAAc,IAAI,CAAC,CAAC,OAAS,IAAI,QAAQ,CAAC,UAAU,CAAC;IAEvE,IAAI,CAAC,eAAe,cAAc;QAChC,MAAM,kBAAkB,MAAM,IAAA,+IAAY;QAE9C,IAAI,CAAC,iBAAiB;YACpB,IAAI,QAAQ,GAAG;YACf,OAAO,gMAAY,CAAC,QAAQ,CAAC;QAC/B;QAEA,MAAM,UAAU,gBAAgB,IAAI;QAEhC,MAAM,WAAW,gMAAY,CAAC,IAAI;QAElC,SAAS,OAAO,CAAC,GAAG,CAAC,eAAe,QAAQ,WAAW,EAAE;YACvD,UAAU;YACV,MAAM;QACR;QACA,IAAI,QAAQ,YAAY,EAAE;YACxB,SAAS,OAAO,CAAC,GAAG,CAAC,gBAAgB,QAAQ,YAAY,EAAE;gBACzD,UAAU;gBACV,MAAM;YACR;QACF;QAEA,OAAO;IACT;IAEA,IAAI,CAAC,eAAe,WAAW;QAC7B,IAAI,QAAQ,GAAG;QACf,OAAO,gMAAY,CAAC,QAAQ,CAAC;IAC/B;IAEA,IAAI,eAAe,UAAU;QAC3B,IAAI,QAAQ,GAAG;QACf,OAAO,gMAAY,CAAC,QAAQ,CAAC;IAC/B;IAEA,OAAO,gMAAY,CAAC,IAAI;AAC1B;AAEO,MAAM,SAAS;IACpB,SAAS;QAAC;QAAmB;QAAiB;QAAY;KAAW;AACvE"}}]
}